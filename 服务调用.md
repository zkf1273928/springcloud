###进程内的负载均衡(服务器上项目之间的负载均衡)
##@LoadBalanced+restTemplate实现轮询负载均衡
* 自建一个config包在restTemplate类上使用LoadBalanced注解来实现
* xxxForObject()方法：返回的是响应体中的数据
* xxxForEntity()方法：返回的是entity对象，包含响应体数据、响应体信息(状态码等)
##ribbon需要和RestTemplate结合使用 eureka自带ribbon
1.调用方法
```text
xxxForObject()方法：返回的是响应体中的数据
xxxForEntity()方法：返回的是entity对象，包含响应体数据、响应体信息(状态码等)
```
2.负载均衡算法
```text
Riboon使用 IRule 接口，根据特定算法从所有服务中,选择一个服务。而I Rule 接口有7个实现类。每个实现类代表一个负载均衡算法：
com.netflix.loadbalancer.RoundRobinRule：轮询
com.netflix.loadbalancer.RandomRule：随机
com.netflix.loadbalancer.RetryRule：先轮询，失败则在指定时间内进行重试
WeightedResponseTimeRule：对轮询的扩展，响应速度越快权重越大
BestAvailableRule：先过滤处于断路状态的服务，选择一个并发量最小的服务
AvailabilityFilteringRule：先过滤故障实例，再选择并发较小的实例
ZoneAvoidanceRule：默认规则，根据Server所在区域的性能和可用性选择服务器。
```
3.指定负载均衡算法
* IRule 自定义配置类不能放在@ComponentScan所扫描的当前包以及子包下（有@SpringBootApplication注解的Main所在的包）
```java
@Configuration
public class MySelfRule {
    @Bean
    public IRule myRule(){
        return new RandomRule();//随机负载均衡算法
    }
}
```
4.主启动类
* configuration表示自定义的负载均衡算法
```java
@RibbonClient(name = "CLOUD-PAYMENT-SERVICE",configuration = MySelfRule.class)
```
5.自定义负载均衡算法（实现轮询算法）
```java
@Component
public class MyLB implements LoadBalancer {

    private AtomicInteger atomicInteger = new AtomicInteger(0);

    private final int getAndIncrement(){
        int current;
        int next;
        do{
            current = this.atomicInteger.get();
            next = current >= Integer.MAX_VALUE ? 0 : current+1;
        }while(!this.atomicInteger.compareAndSet(current,next));
        System.out.println("****next: "+next);
        return next;
    }

    @Override
    public ServiceInstance instances(List<ServiceInstance> serviceInstances) {
        int index = getAndIncrement() % serviceInstances.size();
        return serviceInstances.get(index);
    }
}
```
###openfeign可以单独使用(通过服务注册中心的applicationname来调用服务运行)
* feign底层集成了ribbon和restTemplate
1.pom
```xml
<!-- openfeign -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```
2.配置文件
```yaml
server:
  port: 80

eureka:
  client:
    register-with-eureka: false
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
```
3.主启动类
```java
 @SpringBootApplication
 @EnableFeignClients //开启
 public class OrderFeginMain80 {
     public static void main(String[] args){
         SpringApplication.run(OrderFeginMain80.class,args);
     }
 }
```
4.fegin需要调用的其他的服务的接口
```java
@FeignClient(value = "CLOUD-PAYMENT-SERVICE")
public interface PaymentService {

    @GetMapping("/payment/get/{id}")
    public CommonResult getPaymentById(@PathVariable("id") Long id);
}
```
5.controller
```java
@RestController
@Slf4j
@RequestMapping("/consumer")
public class OrderFeginController {

    @Resource
    private PaymentService paymentService;

    @GetMapping("/payment/get/{id}")
    public CommonResult<Payment> getPyamentById(@PathVariable("id")Long id){
        return paymentService.getPaymentById(id);
    }
}
```
6.OpenFeign超时机制
* OpenFeign 默认等待时间是1秒，超过1秒会直接报错
```yaml
 ribbon:
    # 建立连接后，在服务端读取数据的时间
    ReadTimeout: 5000
    # 建立连接所需的时间
    ConnetTimeout: 5000
```
7.Openfeign日志
* 日志级别
* NOEE：默认，不显示日志
* BASIC：仅记录请求方法、URL、响应状态码以及执行时间
* HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息
* FULL：除了 HEADERS 中定义的信息外，还有请求和响应的正文以及元数据
* 使用方法,创建日志类
```java
@Configuration
public class FeignConfig {
    @Bean
    public Logger.Level feignLoggerLevel(){
        return Logger.Level.FULL;//日志级别
    }
}
```
```yaml
logging:
  level:
    # feign 日志以什么级别监控哪个接口
    com.moke.springcloud.service.PaymentService: debug
```
###集中式负载均衡Nginx(服务器之间的负载均衡)后续添加